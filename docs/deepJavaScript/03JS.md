---
title: 高阶函数和闭包
date: 2021-12-07
categories:
 - JavaScript
tags:
 - JavaScript
 - 闭包
---

<!-- more -->

##  JavaScript 高阶函数

* 函数可以作为**另一个函数的参数**，也可以作为**另一个函数的返回值**来使用 (称为高阶函数）

```js
function foo(fn){
    //将函数作为另一个函数的参数
    fn()
}

function bar(){
    console.log("bar")
}

foo(bar)
```



函数作为返回值

```js
function makeAdder(count){
    function add(num){
        return count + num
    }
    return add
}

var add5 = makeAdder(5)
console.log(add5(6))
```

### 数组中的高阶函数

#### filter 

```js
//filter:过滤
//[10,5,11,100,55]
var newNums = nums.filter((item,index,arr) => {
    return item % 2 === 0 //偶数
    // false 不返回 true 返回 
})
```



#### map

```js
var newNums = nums.map((item) => {
    return item * 10
    // 返回对数组映射，对数组进行一些改变
})
```



#### forEach

```js
nums.forEach((item) =>{
    //没有返回值
    //对数组进行迭代操作
})
```



#### find

```js
//[10,5,11,100,55]
var item = num.find((item) =>{
	return item === 11
})


```



#### reduce

```js
//统计
nums.reduce((preValue,item) =>{
	return preValue + item
},0)
```



## 闭包

### 闭包的定义

![](https://s2.loli.net/2021/12/06/Dyc4UXIgzG9dw2x.png)



![](https://s2.loli.net/2021/12/06/ilKSwXHfYxAMpUL.png)

### 闭包的实现

![](https://s2.loli.net/2021/12/06/kJG1taj2zO7xrY4.png)

闭包是由**两部分**组成的：**函数+可以访问的自由变量**

### 闭包的内存泄露

#### 函数执行时的内存

**当函数解析时**

GO对象提前被创建出来，在内存里面会有一个执行上下文ECStack调用栈。在执行全局代码时，会创建一个全局执行上下文。在执行全局上下文的时候，会有一个VO（对应GO）,开始向GO对象添加东西，会给函数创建一个函数对象，同时在GO里面添加一个内存地址。同时在创建函数对象时，会存两个东西，**父级作用域**和**执行体**。在这时就确定了函数的作用域。

![](https://s2.loli.net/2021/12/06/EXJjyL9mMBAOP7K.png)

**在真正执行代码时**

会创建函数执行上下文（包括VO和执行）和AO对象，对函数内部进行解析，在AO中进行变量定义赋值，会把VO指向AO，开始执行代码改变变量的值。 然后因为垃圾回收机制，会把AO销毁。

#### 闭包执行时的内存

因为在执行代码时，函数内部的函数创建的函数对象中的**父级作用域**会指向**父级函数的的AO**，所以不会被垃圾回收机制销毁。

![](https://s2.loli.net/2021/12/06/OLKXMN3mFkbCJPt.png)



#### 解决闭包产生的内存泄漏

将函数指向null，由于垃圾回收机制，会将函数销毁掉。

![](https://s2.loli.net/2021/12/06/7eB2jLI18KOW9Jk.png)

闭包的自由变量销毁：JS引擎会将没有用到的自由变量从AO中销毁。