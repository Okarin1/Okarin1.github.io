---
title: ES6其他知识点
date: 2022-02-11
categories:
 - JavaScript
tags:
 - JavaScript
---

<!-- more -->





## 模板字符串

```js
const myName = 'okarin'
const myAge = 18
const myHeight = 1.73

const message = `my name is ${myName},my age is ${myAge}, my height is ${myHeight}`

console.log(message)
```

同时，模板字符串里面可以**使用JS表达式**

```js
const info = `age double is ${myAge * 2}`
```

```js
const info = `age double is ${doubleAge()}`

function doubleAge(){
    return myAge * 2
}
```

## 标签模板字符串

 ```js
 function foo(m,n){
     console.log(m,n)
 }
 
 const name = "okarin"
 
 foo`he${name}llo`
 
 //[ 'he', 'llo' ] okarin
 ```

* 第一个参数是模板字符串的整个字符串，只是被切成了块，放在了一个数组中。
* 第二个参数是模板字符串中的${ }，以此类推。

 ## 函数的默认参数

```js
function foo(m = 'aaa',n = 'bbb'){
    console.log(m,n)
}

foo()
```

ES6可以给函数参数提供默认值

## 对象参数默认值以及解构

```js
function printInfo({name,age} = {name:"okarin",age:18})
{
    console.log(info.name,info.age)
}

printInfo({name:"retr0",age:19})
```

```js
function printInfo({name = "oakrin",age = 18} = {})
{
    console.log(info.name,info.age)
}

printInfo({name:"retr0",age:19})
```

### 默认值的补充

```js
function bar (x , y , z = 30){
    console.log(x,y,z)
}
```

另外参数的默认值我们通常会将其**放到最后**（在很多语言中，如果不放到最后其实会报错的）：但是JavaScript允许不将其放到最后，但是意味着还是会按照顺序来匹配；
另外默认值会改变函数的length的个数，默认值以及后面的参数都不计算在length之内了。

## 函数的剩余参数

ES6中引用了rest parameter，可以将不定数量的参数放入到一个数组中：

> 如果最后一个参数是`...`为前缀的，那么它会将剩余的参数放到该参数中，并且作为一个数组；

```js
function foo(m,n,...args){
    console.log(m,n)// 1 2
    console.log(args)//[3,4,5]
    console.log(arguments)//[Arguments] { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5 }
}

foo(1,2,3,4,5)
```

**剩余参数和 arguments 的区别：**

* 剩余参数只包含那些**没有对应形参的实参**，而 **arguments 对象包含了传给函数的所有实参**；
* **arguments 对象不是一个真正的数组**，而 **rest 参数是一个真正的数组**，可以进行数组的所有操作；
* arguments是早期的 ECMAScript 中为了方便去获取所有的参数提供的一个数据结构，而 rest 参数是 **ES6 中提供**并且希望以此来替代 arguments 的；

**剩余参数必须放到最后！**

### ES6箭头函数的补充

```js
var foo = () => {
    console.log("foo")
}
console.log(fo.prototype) //undefind

var f = new foo()//TypeError: foo is not a constructor

```

* **箭头函数是没有显式原型的，所以不能作为构造函数，使用new来创建对象；**

## 展开语法(Spread syntax)

* 可以在函数调用/数组构造时，将数组表达式或者string在语法层面展开；

* 还可以在构造字面量对象时，将对象表达式按key—value的方式展开；
* 展开语法的场景：
  * 在函数调用时使用；
  * 在数组构造时使用；
  * 在构建对象字面量使用（ES9新增）

```js
const names = ["abc", "cba", "nba"]
const name = "abc"
const info = {
  name: "okarin",
  age: "18",
}

function foo(x, y, z) {
  console.log(x, y, z) 
}

foo.apply(null, names)//abc cba nba
foo(...names)//abc cba nba
foo(...name)//a b c

const newNames = [...names, ...name]
console.log(newNames)//[ 'abc', 'cba', 'nba', 'a', 'b', 'c' ]

const obj = { ...info, city: "chengdu" }
console.log(obj)//{ name: 'okarin', age: '18', city: 'chengdu' }   

```

**注意：展开运算符其实进行的是一个浅拷贝**



