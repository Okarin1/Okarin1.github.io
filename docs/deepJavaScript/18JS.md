---
title: async 和 await
date: 2022-06-07
categories:
  - JavaScript
tags:
  - JavaScript
  - async
  - await
---

## 异步请求的处理方式

假设有一个需求，需要多次请求

```js
需求：
1: url:okarin -> res: okarin
2: url:res+ 'aaa' ->okarinaaa
3: url:res+ 'bbb' ->okarinaaabbb
4: url:res+ 'ccc' ->okarinaaabbbccc
```

请求的 Promise

```js
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(url)
    }, 1000)
  })
}
```

### 方案一：多次回调（回调地狱）

```js
requestData("okarin").then((res) => {
  requestData(res + "aaa").then((res) => {
    requestData(res + "bbb").then((res) => {
      requestData(res + "ccc").then((res) => {
        console.log(res)
      })
    })
  })
})
```

会形成回调地狱

### 方案二：Promise 返回值

```js
requestData("okarin")
  .then((res) => {
    return requestData(res + "aaa")
  })
  .then((res) => {
    return requestData(res + "bbb")
  })
  .then((res) => {
    return requestData(res + "ccc")
  })
  .then((res) => {
    console.log(res)
  })
```

可读性和可维护性差

### 方案三：Promise + Generator

```js
function* getData() {
  const res1 = yield requestData("okarin")
  const res2 = yield requestData(res1 + "aaa")
  const res3 = yield requestData(res2 + "bbb")
  const res4 = yield requestData(res3 + "ccc")
  console.log(res4)
}

const generator = getData()
generator.next().value.then((res) => {
  generator.next(res).value.then((res) => {
    generator.next(res).value.then((res) => {
      generator.next(res).value.then((res) => {
        generator.next(res)
      })
    })
  })
})
```

### 使用递归函数优化

```js
function execGenerator(genFn) {
  const generator = genFn()
  function exec(res) {
    const result = generator.next(res)
    if (result.done) {
      return result.value
    }
    result.value.then((res) => {
      exec(res)
    })
  }
  exec()
}

execGenerator(getData)
```

## 方案四：async/await

```js
async function getData() {
  const res1 = await requestData("okarin")
  const res2 = await requestData(res1 + "aaa")
  const res3 = await requestData(res2 + "bbb")
  const res4 = await requestData(res3 + "ccc")
  console.log(res4)
}

getData()
```

async/await 的原理就是使用 Promise 和生成器。

## async 异步函数

async 关键字用于声明一个异步函数

```js
async function foo() {}

const foo = async () => {}
```

### 异步函数的执行流程

默认情况下 async 函数跟普通函数的执行流程没有区别，会被同步执行。

```js
async function foo() {
  console.log("foo function start")
  console.log("hello world")
  console.log("foo function end")
}

console.log("111111")
foo()
console.log("222222")

//111111
// foo function start
// hello world
// foo function end
// 222222
```

### 异步函数的返回值

异步函数也可以有返回值，但是会被包裹到 Promise.resolve 中。

```js
async function foo() {
  console.log("foo function start")
  console.log("hello world")
  console.log("foo function end")
  return "aaa"
}

const promise = foo()
promise.then((res) => {
  console.log(res)
})

//foo function start
//hello world
//foo function end
//aaa
```

如果返回值是一个对象并实现了 thenable，那么会由对象的 then 方法来决定。

```js
async function foo() {
  console.log("foo function start")
  console.log("hello world")
  console.log("foo function end")
  return {
    then: function (resolve, reject) {
      resolve("bbb")
    },
  }
}

const promise = foo()
promise.then((res) => {
  console.log(res)
})

//foo function start
//hello world
//foo function end
//bbb
```

如果返回值是一个 Promise，Promise.resolve 的状态会由返回的 Promise 决定。

```js
async function foo() {
  console.log("foo function start")
  console.log("hello world")
  console.log("foo function end")

  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("ccc")
    }, 2000)
  })
}
const promise = foo()
promise.then((res) => {
  console.log(res)
})

//foo function start
//hello world
//foo function end
//ccc
```

### 异步函数的异常

如果在 async 中抛出了异常，那么程序它并不会像普通函数一样报错，而是会作为 Promise 的 reject 来传递；

```js
async function foo() {
  console.log("foo function start")
  console.log("hello world")

  throw new Error("err message!")
  //异步函数内部后续代码
  console.log("foo function end")
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("ccc")
    }, 2000)
  })
}

console.log("111111")
const promise = foo()
promise
  .then((res) => {
    console.log(res)
  })
  .catch((err) => {
    console.log("Error:", err)
  })

//后续代码
console.log("222222")
console.log("333333")

// 111111
// foo function start
// hello world
// 222222
// 333333
// Error: Error: err message! ...
```

可以发现，异步请求中抛出的异常，会中断异步函数的执行，但是**不会影响函数外部后续代码的执行**。

### await 关键字

async 函数内部可以使用 await 关键字，而**普通函数中是不可以**的。

await 关键字的特点：

- 通常使用 await 是后面会跟上一个表达式，这个表达式会**返回一个 Promise**；
- 那么 await 会等到 Promise 的状态**变成 fulfilled 状态**，之后**继续执行异步函数**；如果 await 后面是一个普通的值，那么会直接返回这个值；
- 如果 await 后面是一个 thenable 的对象，那么会根据对象的 then 方法调用来决定后续的值；

await 后接 Promise

```js
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(url)
    }, 1000)
  })
}

async function foo() {
  const res = await requestData("okarin")
  console.log(res)
  console.log("111111111111111")
}

foo()

//okarin
//111111111111111
```

await 后接 thenable

```js
async function foo() {
  const res = await {
    then: function (resolve, reject) {
      setTimeout(() => {
        resolve("abc")
      }, 2000)
    },
  }
  console.log(res)
  console.log("111111111111111")
}

foo()

//abc
//111111111111111
```

await 后 Promise 的状态如果变成 rejected，会把 reject 的值作为整个函数返回的 Promise 的值，那么需要使用 catch 回调。

```js
function requestData(url) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      //   resolve(url)
      reject("error message!")
    }, 1000)
  })
}

async function foo() {
  console.log("111111111111111")
  const res = await requestData("okarin")
  console.log(res)
  console.log("222222222222222")
}

foo().catch((err) => {
  console.log("Error:", err)
})

//111111111111111
//Error: error message!
```

#### await 执行流程

```js
function requestData(url) {
  console.log("222222222222222")
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(url)
      // reject("error message!")
    }, 1000)
  })
}

async function foo() {
  console.log("111111111111111")
  const res = await requestData("okarin")
  console.log(res)
  console.log("333333333333333")
}

console.log("script start")
foo()
console.log("script end")

// script start
// 111111111111111
// 222222222222222
// script end
// okarin
// 333333333333333
```
